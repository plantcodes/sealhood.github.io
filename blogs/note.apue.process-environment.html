<!DOCTYPE html>
<html>
<head>
<title>note.apue.process-environment</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Process Environment</h2>
<h3>main Function</h3>
<h3>Process termination</h3>
<p><strong>Normal termination occurs in five ways:</strong></p>
<ol>
<li>Return from main</li>
<li>Calling exit</li>
<li>Calling _exit or _Exit</li>
<li>Return of the last thread from its start routine</li>
<li>Calling pthread_exit from the last thread</li>
</ol>
<p><strong>Abnormal termination occurs in three ways:</strong></p>
<ol>
<li>Calling abort</li>
<li>Receipt of a signal</li>
<li>Response of the last thread to a cancellation request </li>
</ol>
<p><strong>Exit Functions</strong></p>
<pre><code>#include &lt;stdlib.h&gt;     # ISO C
void exit(int status);  # performs certain cleanup processing and then returns to the kernel.
void _Exit(int status); # return to the kernel immediately
#include &lt;unistd.h&gt;     # POSIX
void _exit(int status); # return to the kernel immediately
</code></pre>

<p>With ISO C, a process can register at least 32 functions that are automatically called by exit.These are called <strong>exit handlers</strong> and are registered by calling the <strong>atexit function</strong>.</p>
<pre><code>#include &lt;stdlib.h&gt;     # ISO C
int atexit(void (*func)(void));
</code></pre>

<p>The following figure shows how a C program is started and how it terminates.
<img src="./images/c-program-start-terminate.jpg" alt="c-program-start-terminate.jpg" /></p>
<h3>Environment list</h3>
<p><strong>Environment list</strong> is an array of character pointers, <code>extern char **environ</code> is a global variable, a pointer to the array of character pointers. It can illustrated as:</p>
<p><img src="./images/environment-list.jpg" alt="enlist" /></p>
<p>Access to specific environment variables is normally through the getenv and putenv functions, instead of through the environ variable. But to go through the entire environment, the environ pointer must be used.</p>
<h3>Memory layout of a C program</h3>
<p>A c program is composed of the following pieces:</p>
<ul>
<li>Text segment, consisting of the machine instructions that the CPU executes. </li>
<li>Initialized data segment, the C declaration <code>int   maxcount = 99;</code> appearing outside any function causes this variable to be stored in the initialized data segment with its initial value.</li>
<li>Unitialized data segment, data in this segment is initialized by the kernel to arithmetic 0 or null pointers before the program starts executing. The C declaration <code>long   sum[1000];</code> appearing outside any function causes this variable to be stored in the uninitialized data segment.</li>
<li>Stack</li>
<li>Heap</li>
<li>
<img src="./images/memory-arrangement.jpg" alt="mr" /></li>
</ul>
<blockquote>
<p>Several more segment types exist in an a.out, containing <strong>the symbol table</strong>, <strong>debugging information</strong>, <strong>linkage tables</strong> for dynamic shared libraries, and the like. These additional sections don’t get loaded as part of the program’s image executed by a process.</p>
</blockquote>
<h3>setjmp and longjmp Functions</h3>
<pre><code>#include &lt;setjmp.h&gt;
int setjmp(jmp_buf env);    # Returns: 0 if called directly, nonzero if returning from a call to longjmp
void longjmp(jmp_buf env, int val);
</code></pre>

<p>The <code>setjmp</code> function save execution environment for longjmp to roll back. Mostly, the <strong>automatic</strong>, <strong>register</strong> are't rolled back, and the values of them are <code>it depends</code>. Global(extern, malloc) and static variable are rolled back.
The <strong>volatile variables</strong> are not optimized by compiler, <strong>because it can be modified by other thread</strong>, can be rolled back. While the <strong>automatic</strong>, <strong>register</strong> is(may be) optimized to register. </p>
<h3>getrlimit and setrlimit Functions</h3>
<pre><code>#include &lt;sys/resource.h&gt;
int getrlimit(int resource, struct rlimit *rlptr);  # Both return: 0 if OK, –1 on error
int setrlimit(int resource, const struct rlimit *rlptr); # Both return: 0 if OK, –1 on error
</code></pre>

<p><img src="./images/struct-rlimit.jpg" alt="struct-rlimit.jpg" /></p>
<p>Three rules govern the changing of the resource limits.</p>
<ol>
<li>A process can change its soft limit to a value less than or equal to its hard limit.</li>
<li>A process can lower its hard limit to a value greater than or equal to its soft limit. This lowering of the hard limit is irreversible for normal users.</li>
<li>Only a superuser process can raise a hard limit.</li>
</ol>
<p>The resource argument takes one of the following values.</p>
<p><img src="./images/resource-limits.jpg" alt="resource-limits.jpg" /></p>
<ul>
<li><strong>RLIMIT_AS</strong> The maximum size in bytes of a process’s total available memory. This affects the sbrk function and the mmap function.</li>
<li><strong>RLIMIT_CORE</strong> The maximum size in bytes of a core file. A limit of 0 prevents the creation of a core file.</li>
<li><strong>RLIMIT_CPU</strong> The maximum amount of CPU time in seconds. When the soft limit is exceeded, the SIGXCPU signal is sent to the process.</li>
<li><strong>RLIMIT_DATA</strong> The maximum size in bytes of the data segment: the sum of the initialized data, uninitialized data, and heap from Figure 7.6.</li>
<li><strong>RLIMIT_FSIZE</strong> The maximum size in bytes of a file that may be created. When the soft limit is exceeded, the process is sent the SIGXFSZ signal.</li>
<li><strong>RLIMIT_MEMLOCK</strong> The maximum amount of memory in bytes that a process can lock into memory using mlock(2).</li>
<li><strong>RLIMIT_MSGQUEUE</strong> The maximum amount of memory in bytes that a process can allocate for POSIX message queues.</li>
<li><strong>RLIMIT_NICE</strong> The limit to which a process’s nice value can be raised to affect its scheduling priority.</li>
<li><strong>RLIMIT<em>NOFILE</strong>  The maximum number of open files per process. Changing this limit affects the value returned by the sysconf function for its <em>SC</em>OPEN</em>MAX argument.</li>
<li><strong>RLIMIT<em>NPROC</strong>  The maximum number of child processes per real user ID. Changing this limit affects the value returned for <em>SC</em>CHILD</em>MAX by the sysconf function</li>
<li><strong>RLIMIT_NPTS</strong> The maximum number of pseudo terminals that a user can have open at one time.</li>
<li><strong>RLIMIT_RSS</strong>  Maximum resident set size (RSS) in bytes. If available physical memory is low, the kernel takes memory from processes that exceed their RSS.</li>
</ul>
<blockquote>
<p>In computing, resident set size is the portion of a process's memory that is held in RAM. The rest of the memory exists in swap or the filesystem (never loaded or previously unloaded parts of the executable).</p>
</blockquote>
<ul>
<li><strong>RLIMIT_SBSIZE</strong>  The maximum size in bytes of socket buffers that a user can consume at any given time.</li>
<li><strong>RLIMIT_SIGPENDING</strong> The maximum number of signals that can be queued for a process. This limit is enforced by the sigqueue function .</li>
<li><strong>RLIMIT_STACK</strong> The maximum size in bytes of the stack. </li>
<li><strong>RLIMIT_SWAP</strong> The maximum amount of swap space in bytes that a user can consume.</li>
<li><strong>RLIMIT<em>VMEM</strong> This is a synonym for RLIMIT</em>AS.</li>
</ul>
<p><strong>ISO C string-creation operator (#)</strong> </p>
<p>The <code>#name</code> represent string <code>&quot;name&quot;</code>.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
